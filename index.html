<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CAN AQHI Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin="">
  <style>
    html,body{height:100%;margin:0}
    #map{height:100vh;width:100%}
    .ctl {
      background:#fff; padding:8px 10px; border:1px solid #888; border-radius:6px;
      box-shadow: 0 1px 3px rgba(0,0,0,.2); font: 14px/1.2 system-ui, Arial;
    }
    .legend {
      position: fixed; bottom: 18px; left: 12px; background: #fff; border:1px solid #888; border-radius:6px;
      padding:8px; font:12px/1.2 system-ui, Arial; z-index: 9999;
    }
    .legend .sw{display:inline-block;width:14px;height:14px;border:1px solid #333;margin-right:4px}
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>
  <script>
  (async function() {
    const map = L.map('map').setView([56,-106],5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      maxZoom:18, attribution:'&copy; OpenStreetMap'
    }).addTo(map);

    // --- palette / helpers ---
    const PALETTE = ["#01cbff","#0099cb","#016797","#fffe03","#ffcb00","#ff9835","#fd6866","#fe0002","#cc0001","#9a0100","#640100"];
    const MISSING = "#9e9e9e";
    function aqhiColor(v){
      if (v==null || isNaN(v)) return MISSING;
      v = +v;
      if (v<=1) return PALETTE[0];
      if (v<=2) return PALETTE[1];
      if (v<=3) return PALETTE[2];
      if (v<=4) return PALETTE[3];
      if (v<=5) return PALETTE[4];
      if (v<=6) return PALETTE[5];
      if (v<=7) return PALETTE[6];
      if (v<=8) return PALETTE[7];
      if (v<=9) return PALETTE[8];
      if (v<=10) return PALETTE[9];
      return PALETTE[10];
    }
    async function fetchJSON(url){
      const r = await fetch(url + '?v=' + Date.now(), {cache:'no-store'});
      if (!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
      return r.json();
    }

    // Map a friendly category to the most appropriate forecast period index by label.
    function pickPeriodIndexByCategory(p, category){
      const labels = [];
      for (let i=1;i<=5;i++){
        const lbl = (p[`p${i}_label`] || '').toString().toLowerCase();
        labels.push(lbl);
      }
      const has = (i, s) => labels[i-1].includes(s);

      const isToday = i => has(i,'today') || has(i,'this morning') || has(i,'this afternoon') || (has(i,'this evening') && !has(i,'tonight'));
      const isTonight = i => has(i,'tonight') || has(i,'overnight') || has(i,'this night');
      const isTomorrow = i => (has(i,'tomorrow') && !has(i,'night')) || has(i,'tomorrow daytime') || has(i,'tomorrow afternoon') || has(i,'tomorrow morning');
      const isTomorrowNight = i => has(i,'tomorrow night') || has(i,'tomorrow evening') || has(i,'tomorrow overnight');

      let test;
      if (category==='today') test = isToday;
      else if (category==='tonight') test = isTonight;
      else if (category==='tomorrow') test = isTomorrow;
      else if (category==='tomorrow_night') test = isTomorrowNight;

      if (test){
        for (let i=1;i<=5;i++) if (test(i)) return i;
      }
      const fallback = { today:1, tonight:2, tomorrow:3, tomorrow_night:4 };
      return fallback[category] || 1;
    }

    // --- load datasets ---
    let obsLayer=null, fcstLayer=null;

    // Observed
    try{
      const obs = await fetchJSON('./data/aqhi_observations.geojson');
      obsLayer = L.geoJSON(obs, {
        pointToLayer: (f, latlng) => {
          const p = f.properties||{};
          const c = p.color || aqhiColor(p.aqhi);
          const when = p.observation_datetime_text_en || p.observed || '';
          return L.circleMarker(latlng,{radius:6,color:c,fillColor:c,weight:1,fillOpacity:0.9})
            .bindPopup(`<b>${p.name ?? '(unknown)'}</b><br>AQHI: ${p.aqhi ?? '—'}<br>${when}`);
        }
      }).addTo(map);
    }catch(e){ console.warn('Observed not loaded:', e); }

    // Forecast (single layer, recolored by selected category)
    const forecastMarkers = [];
    let currentCategory = 'today'; // default

    function popupTable(p){
      const cats = [
        ['today','Today'],
        ['tonight','Tonight'],
        ['tomorrow','Tomorrow'],
        ['tomorrow_night','Tomorrow night'],
      ];
      let html = '<table style="font-size:12px">';
      for (const [key,label] of cats){
        const idx = pickPeriodIndexByCategory(p, key);
        const val = p[`p${idx}_aqhi`];
        html += `<tr><td>${label}</td><td style="padding-left:8px;">AQHI ${val ?? '—'}</td></tr>`;
      }
      html += '</table>';
      return html;
    }

    function recolorForecastMarkers(){
      for (const m of forecastMarkers){
        const p = m.__aqhiProps || {};
        const idx = pickPeriodIndexByCategory(p, currentCategory);
        const val = p[`p${idx}_aqhi`];
        const c = aqhiColor(val);
        m.setStyle({color:c, fillColor:c});
        const labelMap = {today:'Today', tonight:'Tonight', tomorrow:'Tomorrow', tomorrow_night:'Tomorrow night'};
        const chosenLabel = labelMap[currentCategory] || 'Next';
        m.setPopupContent(
          `<b>${p.name ?? '(unknown)'}</b><br>` +
          `${chosenLabel}: AQHI ${val ?? '—'}<br>` +
          popupTable(p)
        );
      }
    }

    try{
      const fcst = await fetchJSON('./data/aqhi_forecasts.geojson');
      fcstLayer = L.geoJSON(fcst, {
        pointToLayer: (f, latlng) => {
          const p = f.properties||{};
          const idx = pickPeriodIndexByCategory(p, currentCategory);
          const val = p[`p${idx}_aqhi`];
          const c = aqhiColor(val);
          const m = L.circleMarker(latlng,{radius:6,color:c,fillColor:c,weight:1,fillOpacity:0.9})
            .bindPopup(
              `<b>${p.name ?? '(unknown)'}</b><br>` +
              `Today: AQHI ${val ?? '—'}<br>` +
              popupTable(p)
            );
          m.__aqhiProps = p;
          forecastMarkers.push(m);
          return m;
        }
      });
      // note: not added to map by default (Observed starts active)
    }catch(e){ console.warn('Forecast not loaded:', e); }

    // --- Exclusive layer toggling ---
    function showObserved() {
      if (fcstLayer && map.hasLayer(fcstLayer)) map.removeLayer(fcstLayer);
      if (obsLayer && !map.hasLayer(obsLayer)) obsLayer.addTo(map);
      setPeriodCtlEnabled(false); // disable period radios when observed
    }
    function showForecast() {
      if (obsLayer && map.hasLayer(obsLayer)) map.removeLayer(obsLayer);
      if (fcstLayer && !map.hasLayer(fcstLayer)) fcstLayer.addTo(map);
      recolorForecastMarkers();   // ensure current period colors apply
      setPeriodCtlEnabled(true);  // enable period radios when forecast is active
    }
    function fitToActive() {
      const active = map.hasLayer(obsLayer) ? obsLayer : (map.hasLayer(fcstLayer) ? fcstLayer : null);
      if (active && active.getLayers && active.getLayers().length) {
        map.fitBounds(active.getBounds(), { padding: [20, 20] });
      }
    }

    // --- Top-right: Observed vs Forecast (radio) ---
    const ToggleCtl = L.Control.extend({
      onAdd: function() {
        const div = L.DomUtil.create('div', 'ctl');
        div.id = 'layer-toggle-ctl';
        div.style.minWidth = '200px';
        div.innerHTML = `
          <div><b>Layer</b></div>
          <label><input type="radio" name="view" value="observed" checked> Current (Observed)</label><br>
          <label><input type="radio" name="view" value="forecast"> Forecast</label>
        `;
        L.DomEvent.disableClickPropagation(div);
        div.querySelectorAll('input[name="view"]').forEach(r => {
          r.addEventListener('change', (e) => {
            if (e.target.value === 'observed') {
              showObserved();
            } else {
              showForecast();
            }
            fitToActive();
          });
        });
        return div;
      },
      onRemove: function() {}
    });
    new ToggleCtl({ position: 'topright' }).addTo(map);

    // --- Top-left: Forecast period (radio) ---
    const PeriodCtl = L.Control.extend({
      onAdd: function(){
        const div = L.DomUtil.create('div','ctl');
        div.id = 'forecast-period-ctl';
        div.innerHTML = `
          <div><b>Forecast period</b></div>
          <label><input type="radio" name="p" value="today" checked> Today</label><br>
          <label><input type="radio" name="p" value="tonight"> Tonight</label><br>
          <label><input type="radio" name="p" value="tomorrow"> Tomorrow</label><br>
          <label><input type="radio" name="p" value="tomorrow_night"> Tomorrow night</label>
        `;
        L.DomEvent.disableClickPropagation(div);
        div.querySelectorAll('input[name="p"]').forEach(r => {
          r.addEventListener('change', (e) => {
            currentCategory = e.target.value;
            recolorForecastMarkers();
          });
        });
        return div;
      },
      onRemove: function(){}
    });
    new PeriodCtl({position:'topleft'}).addTo(map);

    // Enable/disable period control
    function setPeriodCtlEnabled(enabled){
      const el = document.getElementById('forecast-period-ctl');
      if (!el) return;
      el.style.opacity = enabled ? 1 : 0.5;
      el.style.pointerEvents = enabled ? 'auto' : 'none';
    }

    // Legend
    const legend = document.createElement('div');
    legend.className = 'legend';
    legend.innerHTML = '<b>AQHI</b><br>' +
      PALETTE.map(c => `<span class="sw" style="background:${c}"></span>`).join('') +
      '<div style="margin-top:4px;font-size:11px">1..10, 10+ · grey = missing</div>';
    document.body.appendChild(legend);

    // --- Initial state ---
    showObserved();     // Observed visible, Forecast hidden
    fitToActive();
    setPeriodCtlEnabled(false); // disable forecast period until user selects Forecast
  })();
  </script>
</body>
</html>
